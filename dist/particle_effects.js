/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ParticleSystem.js":
/*!*******************************!*\
  !*** ./src/ParticleSystem.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ParticleSystem\": () => (/* binding */ ParticleSystem)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n\n\nclass ParticleSystem {\n  canvas = null;\n  ctx = null;\n  paused = false;\n  \n  constructor({containerElement, maxAmountOfParticles, particleEmitter, particleFactory}) {\n    // Find containerElement\n    if (!containerElement) return;\n    \n    // Setup our canvas\n    this.ctx = this.initCanvas(containerElement);\n    \n    // Register our particle emitter\n    this.particleEmitter = particleEmitter;\n    this.particleEmitter.init({canvasContext: this.ctx, particleFactory, maxAmountOfParticles});\n    this.update();\n    \n    // React to resize-events\n    this.resizeHandlerDebounced = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce)(() => this.onResize(containerElement), 500);\n    window.onresize = () => {\n      this.paused = true;\n      this.resizeHandlerDebounced();\n    };\n  }\n  \n  initCanvas(containerElement) {\n    const canvas = document.createElement('canvas');\n    canvas.width = containerElement.getBoundingClientRect().width;\n    canvas.height = containerElement.getBoundingClientRect().height;\n    containerElement.appendChild(canvas);\n    return canvas.getContext('2d');\n  }\n  \n  /**\n   * Re-init all particles and scale the canvas if the window resized\n   */\n  onResize(containerElement) {\n    this.ctx.canvas.width = containerElement.getBoundingClientRect().width;\n    this.ctx.canvas.height = containerElement.getBoundingClientRect().height;\n    this.particleEmitter.clearParticles();\n    this.paused = false;\n  }\n  \n  update() {\n    if (!this.paused) {\n      this.particleEmitter.update();\n    }\n    \n    // Keep updating our particles\n    requestAnimationFrame(\n      () => this.update()\n    );\n  }\n}\n\n//# sourceURL=webpack://vanilla-js-particle-effects/./src/ParticleSystem.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ParticleSystem_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ParticleSystem.js */ \"./src/ParticleSystem.js\");\n/* harmony import */ var _particle_emitters_WaveEmitter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./particle_emitters/WaveEmitter.js */ \"./src/particle_emitters/WaveEmitter.js\");\n/* harmony import */ var _particle_emitters_MicroOrganismEmitter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./particle_emitters/MicroOrganismEmitter.js */ \"./src/particle_emitters/MicroOrganismEmitter.js\");\n/* harmony import */ var _particle_emitters_MicroOrganismMagnetEmitter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./particle_emitters/MicroOrganismMagnetEmitter.js */ \"./src/particle_emitters/MicroOrganismMagnetEmitter.js\");\n/* harmony import */ var _particle_factories_image_particle_factory_ImageParticleFactory_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./particle_factories/image_particle_factory/ImageParticleFactory.js */ \"./src/particle_factories/image_particle_factory/ImageParticleFactory.js\");\n/* harmony import */ var _particle_factories_micro_organism_particle_factory_MicroOrganismParticleFactory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./particle_factories/micro_organism_particle_factory/MicroOrganismParticleFactory.js */ \"./src/particle_factories/micro_organism_particle_factory/MicroOrganismParticleFactory.js\");\n/* harmony import */ var _particle_factories_animated_geometry_particle_factory_AnimatedGeometryParticleFactory_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./particle_factories/animated_geometry_particle_factory/AnimatedGeometryParticleFactory.js */ \"./src/particle_factories/animated_geometry_particle_factory/AnimatedGeometryParticleFactory.js\");\n// Import particle systems\n\n\n// Import particle emitters\n\n\n\n\n// Import particle factories\n\n\n\n\n\n// Define ParticleEffects library\nwindow.particleEffects = {\n  ParticleSystem: _ParticleSystem_js__WEBPACK_IMPORTED_MODULE_0__.ParticleSystem,\n  \n  // Define particle emitters\n  emitters: {\n    WaveEmitter: _particle_emitters_WaveEmitter_js__WEBPACK_IMPORTED_MODULE_1__.WaveEmitter,\n    MicroOrganismEmitter: _particle_emitters_MicroOrganismEmitter_js__WEBPACK_IMPORTED_MODULE_2__.MicroOrganismEmitter,\n    MicroOrganismMagnetEmitter: _particle_emitters_MicroOrganismMagnetEmitter_js__WEBPACK_IMPORTED_MODULE_3__.MicroOrganismMagnetEmitter\n  },\n  \n  // Define particle factories\n  particleFactories: {\n    ImageParticleFactory: _particle_factories_image_particle_factory_ImageParticleFactory_js__WEBPACK_IMPORTED_MODULE_4__.ImageParticleFactory,\n    MicroOrganismParticleFactory: _particle_factories_micro_organism_particle_factory_MicroOrganismParticleFactory_js__WEBPACK_IMPORTED_MODULE_5__.MicroOrganismParticleFactory,\n    AnimatedGeometryParticleFactory: _particle_factories_animated_geometry_particle_factory_AnimatedGeometryParticleFactory_js__WEBPACK_IMPORTED_MODULE_6__.AnimatedGeometryParticleFactory\n  }\n};\n\n\n// const containerElement = document.getElementById('particles-container');\n// // initialize our particle system\n// const particleSystem = new ParticleSystem({\n//   containerElement: containerElement,\n//   maxAmountOfParticles: 300,\n//   // particleEmitter: new WaveEmitter({\n//   //   backgroundColor: '#000',\n//   //   minSpeed: 1,\n//   //   maxSpeed: 5,\n//   //   alternateColors: true\n//   // }),\n//   // particleFactory: new ImageParticleFactory({\n//   //   minScale: 0.1,\n//   //   maxScale: 0.5,\n//   // }),\n//   // particleEmitter: new MicroOrganismEmitter({\n//   //   backgroundColor: '#000E2E'\n//   // }),\n//   particleEmitter: new MicroOrganismMagnetEmitter({\n//     backgroundColor: '#000E2E',\n//     magnetRadius: 80\n//   }),\n//   particleFactory: new MicroOrganismParticleFactory({\n//     minRadius: 0.2,\n//     maxRadius: 3,\n//     particleColors: ['#F9314C', '#d8002c', '#7DFFF2']\n//   }),\n//   // particleFactory: new AnimatedGeometryParticleFactory({\n//   //   minWidth: 15,\n//   //   maxWidth: 25,\n//   // }),\n// });\n\n//# sourceURL=webpack://vanilla-js-particle-effects/./src/index.js?");

/***/ }),

/***/ "./src/particle_emitters/EmitterBase.js":
/*!**********************************************!*\
  !*** ./src/particle_emitters/EmitterBase.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EmitterBase\": () => (/* binding */ EmitterBase)\n/* harmony export */ });\nclass EmitterBase {\n  ctx = null;\n  particleFactory = null;\n  particles = [];\n  maxAmountOfParticles = 0;\n  isCreatingParticle = false;\n  \n  constructor() {\n    // Override this method in the extended emitter class\n  }\n  \n  init({ canvasContext, particleFactory }) {\n    // Override this method in the extended emitter class\n  }\n  \n  clearCanvas() {\n    // Override this method in the extended emitter class\n  }\n  \n  clearParticles() {\n    // Override this method in the extended emitter class\n  }\n  \n  /**\n   * Create a new particle\n   * @return {number}\n   */\n  createParticle() {\n    // Override this method in the extended emitter class\n  }\n  \n  updateParticle(particle) {\n    // Override this method in the extended emitter class\n  }\n  \n  update() {\n    // Override this method in the extended emitter class\n  }\n}\n\n//# sourceURL=webpack://vanilla-js-particle-effects/./src/particle_emitters/EmitterBase.js?");

/***/ }),

/***/ "./src/particle_emitters/MicroOrganismEmitter.js":
/*!*******************************************************!*\
  !*** ./src/particle_emitters/MicroOrganismEmitter.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MicroOrganismEmitter\": () => (/* binding */ MicroOrganismEmitter)\n/* harmony export */ });\n/* harmony import */ var _EmitterBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EmitterBase.js */ \"./src/particle_emitters/EmitterBase.js\");\n\n\nclass MicroOrganismEmitter extends _EmitterBase_js__WEBPACK_IMPORTED_MODULE_0__.EmitterBase {\n  ctx = null;\n  particleFactory = null;\n  particles = [];\n  maxAmountOfParticles = 0;\n  isCreatingParticle = false;\n  \n  constructor({ backgroundColor }) {\n    super();\n    this.backgroundColor = backgroundColor || '#000E2E';\n  }\n  \n  init({ canvasContext, particleFactory, maxAmountOfParticles }) {\n    // Store our canvas context\n    this.ctx = canvasContext;\n    // Store our particle factory\n    this.particleFactory = particleFactory;\n    // Store how many particles we are allowed to render\n    this.maxAmountOfParticles = maxAmountOfParticles || 800;\n  }\n  \n  clearCanvas() {\n    this.ctx.globalAlpha = 0.05;\n    this.ctx.fillStyle = this.backgroundColor;\n    this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n    this.ctx.globalAlpha = 1;\n  }\n  \n  clearParticles() {\n    this.particles = [];\n  }\n  \n  /**\n   * Create a new particle\n   * @return {number}\n   */\n  createParticle() {\n    this.isCreatingParticle = true;\n    setTimeout(() => {\n      const initialX = (this.ctx.canvas.width / 2) + (Math.random() * 200 - Math.random() * 200);\n      const initialY = (this.ctx.canvas.height / 2) + (Math.random() * 200 - Math.random() * 200);\n      const behaviouralProperties = {\n        variantx1: Math.random() * 300,\n        variantx2: Math.random() * 400,\n        varianty1: Math.random() * 100,\n        varianty2: Math.random() * 120,\n      };\n      this.particles.push(\n        this.particleFactory.createParticle({\n          canvasContext: this.ctx,\n          behaviouralProperties,\n          initialX,\n          initialY\n        })\n      );\n      this.isCreatingParticle = false;\n    }, 20)\n  }\n  \n  updateParticle(particle) {\n    const x = particle.x + (Math.sin(particle.getLifeTime() / particle.behaviouralProperties.variantx1) * Math.cos(\n      particle.getLifeTime() / particle.behaviouralProperties.variantx2));\n    const y = particle.y + (Math.cos(particle.getLifeTime() / particle.behaviouralProperties.varianty2));\n    particle.setLifeTime(particle.getLifeTime() + 1);\n    particle.setPosition({ x, y });\n  }\n  \n  update() {\n    // Clear our canvas\n    this.clearCanvas();\n    \n    // Loop through particles, animate them and filter away any 'dead' particles\n    this.particles = this.particles.filter((particle) => {\n      this.updateParticle(particle);\n      if (particle.isParticleAlive()) {\n        particle.draw();\n        return true;\n      }\n    });\n    \n    // If we have less particles than 'maxAmountOfParticles', create more particles\n    if (this.particles.length < this.maxAmountOfParticles && !this.isCreatingParticle) {\n      this.createParticle()\n    }\n  }\n}\n\n//# sourceURL=webpack://vanilla-js-particle-effects/./src/particle_emitters/MicroOrganismEmitter.js?");

/***/ }),

/***/ "./src/particle_emitters/MicroOrganismMagnetEmitter.js":
/*!*************************************************************!*\
  !*** ./src/particle_emitters/MicroOrganismMagnetEmitter.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MicroOrganismMagnetEmitter\": () => (/* binding */ MicroOrganismMagnetEmitter)\n/* harmony export */ });\n/* harmony import */ var _EmitterBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EmitterBase.js */ \"./src/particle_emitters/EmitterBase.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"./src/utils.js\");\n\n\n\n/**\n * Particle emitter that initialises particles at random positions on the canvas,\n * and then attracts them to a single point (like a 'magnet').\n * We can give our magnet a radius, once a particle touches our magnet, the particle 'dies'\n */\nclass MicroOrganismMagnetEmitter extends _EmitterBase_js__WEBPACK_IMPORTED_MODULE_0__.EmitterBase {\n  ctx = null;\n  particleFactory = null;\n  particles = [];\n  maxAmountOfParticles = 0;\n  isCreatingParticle = false;\n  \n  constructor({ backgroundColor, magnetRadius }) {\n    super();\n    this.backgroundColor = backgroundColor || '#000E2E';\n    this.magnetRadius = magnetRadius || 80;\n  }\n  \n  init({ canvasContext, particleFactory, maxAmountOfParticles }) {\n    // Store our canvas context\n    this.ctx = canvasContext;\n    // Store our particle factory\n    this.particleFactory = particleFactory;\n    // Store how many particles we are allowed to render\n    this.maxAmountOfParticles = maxAmountOfParticles || 800;\n    \n    // Point of attraction\n    this.pointOfAttraction = {\n      x: this.ctx.canvas.width / 2,\n      y: this.ctx.canvas.height / 2\n    }\n  }\n  \n  clearCanvas() {\n    this.ctx.globalAlpha = 0.08;\n    this.ctx.fillStyle = this.backgroundColor;\n    this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n    this.ctx.globalAlpha = 1;\n  }\n  \n  clearParticles() {\n    this.particles = [];\n    this.pointOfAttraction = {\n      x: this.ctx.canvas.width / 2,\n      y: this.ctx.canvas.height / 2\n    }\n  }\n  \n  /**\n   * Create a new particle\n   * @return {number}\n   */\n  createParticle() {\n    this.isCreatingParticle = true;\n    setTimeout(() => {\n      const initialX = this.ctx.canvas.width * Math.random();\n      const initialY = this.ctx.canvas.height * Math.random();\n      const behaviouralProperties = {\n        s: Math.random() * 2,\n        a: 0\n      };\n      this.particles.push(\n        this.particleFactory.createParticle({\n          canvasContext: this.ctx,\n          behaviouralProperties,\n          initialX,\n          initialY\n        })\n      );\n      this.isCreatingParticle = false;\n    }, 20)\n  }\n  \n  /**\n   * Decide if the given particle position is inside our 'particle magnet'\n   * (magnet is located in our 'point of attraction' and has a radius)\n   * @param currentParticlePos\n   * @return {boolean}\n   */\n  particleIsInsideMagnet(currentParticlePos) {\n    const distance = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.calculateDistance)(currentParticlePos, this.pointOfAttraction);\n    if (distance <= this.magnetRadius) {\n      return true;\n    }\n    return false;\n  }\n  \n  updateParticle(particle) {\n    const currentParticlePos = particle.getPosition();\n    const distance = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.calculateDistance)(currentParticlePos, this.pointOfAttraction);\n    const force = Math.max(100, (1 + distance));\n    \n    // If particle enters our 'magnet' -> move the particle outside of the canvas, so it 'dies' and gets reset\n    if (this.particleIsInsideMagnet(currentParticlePos)) {\n      particle.setLifeTime(particle.getLifeTime() + 1);\n      particle.setPosition({ x: -100, y: -100 });\n    } else {\n      // Particle not yet reached our 'magnet' -> update the particles' position\n      const attr_x = (this.pointOfAttraction.x - currentParticlePos.x) / force;\n      const attr_y = (this.pointOfAttraction.y - currentParticlePos.y) / force;\n      const newParticleXPos = currentParticlePos.x + (Math.cos(particle.behaviouralProperties.a) * (particle.behaviouralProperties.s)) + attr_x;\n      const newParticleYPos = currentParticlePos.y + (Math.sin(particle.behaviouralProperties.a) * (particle.behaviouralProperties.s)) + attr_y;\n      particle.behaviouralProperties.a += (Math.random() > 0.5 ? Math.random() * 0.9 - 0.45 : Math.random() * 0.4 - 0.2);\n      \n      particle.setLifeTime(particle.getLifeTime() + 1);\n      particle.setPosition({ x: newParticleXPos, y: newParticleYPos });\n    }\n  }\n  \n  update() {\n    // Clear our canvas\n    this.clearCanvas();\n    \n    // Loop through particles, animate them and filter away any 'dead' particles\n    this.particles = this.particles.filter((particle) => {\n      this.updateParticle(particle);\n      if (particle.isParticleAlive()) {\n        particle.draw();\n        return true;\n      }\n    });\n    \n    // If we have less particles than 'maxAmountOfParticles', create more particles\n    if (this.particles.length < this.maxAmountOfParticles && !this.isCreatingParticle) {\n      this.createParticle()\n    }\n  }\n}\n\n//# sourceURL=webpack://vanilla-js-particle-effects/./src/particle_emitters/MicroOrganismMagnetEmitter.js?");

/***/ }),

/***/ "./src/particle_emitters/WaveEmitter.js":
/*!**********************************************!*\
  !*** ./src/particle_emitters/WaveEmitter.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WaveEmitter\": () => (/* binding */ WaveEmitter)\n/* harmony export */ });\n/* harmony import */ var _EmitterBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EmitterBase.js */ \"./src/particle_emitters/EmitterBase.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"./src/utils.js\");\n\n\n\nconst radians = (degrees) => degrees * Math.PI / 180;\n\nclass WaveEmitter extends _EmitterBase_js__WEBPACK_IMPORTED_MODULE_0__.EmitterBase {\n  ctx = null;\n  particleFactory = null;\n  particles = [];\n  maxAmountOfParticles = 0;\n  isCreatingParticle = false;\n  \n  constructor({ backgroundColor, minSpeed, maxSpeed, alternateColors }) {\n    super();\n    this.speedRange = { min: (minSpeed || 1), max: (maxSpeed || 5) };\n    this.backgroundColor = backgroundColor || '#000'\n    this.alternateColors = alternateColors;\n  }\n  \n  init({ canvasContext, particleFactory, maxAmountOfParticles }) {\n    // Store our canvas context\n    this.ctx = canvasContext;\n    // Store our particle factory\n    this.particleFactory = particleFactory;\n    // Store how many particles we are allowed to render\n    this.maxAmountOfParticles = maxAmountOfParticles || 200;\n  }\n  \n  clearCanvas() {\n    this.ctx.fillStyle = this.backgroundColor;\n    this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n  }\n  \n  clearParticles() {\n    this.particles = [];\n  }\n  \n  /**\n   * Create a new particle\n   * @return {number}\n   */\n  createParticle() {\n    this.isCreatingParticle = true;\n    setTimeout(() => {\n      // Create a new particle\n      const behaviouralProperties = {\n        a: ([0.5, 1, 2, 0.3, 3][Math.floor(Math.random() * 4)]),\n        steps: (this.ctx.canvas.width / 8),\n        siner: 100 * Math.random(),\n        rotationDirection: Math.random() > 0.5 ? \"-\" : \"+\",\n        rotation: 0,\n        speed: Math.random() * (this.speedRange.max - this.speedRange.min) + this.speedRange.min,\n      };\n      const particle = this.particleFactory.createParticle({\n        canvasContext: this.ctx,\n        behaviouralProperties\n      });\n      particle.setPosition({ x: -particle.getWidth(), y: 0 });\n      particle.setLifeTime(particle.getPosition().x);\n      \n      // Add particle to our particles list\n      this.particles.push(particle);\n      this.isCreatingParticle = false;\n    }, 20)\n  }\n  \n  updateParticle(particle) {\n    const x = particle.getLifeTime();\n    const y = this.ctx.canvas.height / 2 + particle.behaviouralProperties.siner + (particle.behaviouralProperties.a * Math.sin(\n      particle.getLifeTime() / particle.behaviouralProperties.steps)) * 60;\n    const rotation = particle.behaviouralProperties.rotationDirection + radians(particle.getLifeTime());\n    particle.setLifeTime(particle.getLifeTime() + particle.behaviouralProperties.speed);\n    particle.setPosition({ x, y });\n    particle.setRotation(rotation);\n    if (this.alternateColors) {\n      particle.setColor(`hsla(${(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.sineBetween)(1, 100, particle.getLifeTime() / 100)},100%,50%,1)`);\n    }\n  }\n  \n  update() {\n    // Clear our canvas\n    this.clearCanvas();\n    \n    // Loop through particles, animate them and filter away any 'dead' particles\n    this.particles = this.particles.filter((particle) => {\n      this.updateParticle(particle);\n      if (particle.isParticleAlive()) {\n        particle.draw();\n        return true;\n      }\n    });\n    \n    // If we have less particles than 'maxAmountOfParticles', create more particles\n    if (this.particles.length < this.maxAmountOfParticles && !this.isCreatingParticle) {\n      this.createParticle()\n    }\n  }\n}\n\n//# sourceURL=webpack://vanilla-js-particle-effects/./src/particle_emitters/WaveEmitter.js?");

/***/ }),

/***/ "./src/particle_factories/ParticleBase.js":
/*!************************************************!*\
  !*** ./src/particle_factories/ParticleBase.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ParticleBase\": () => (/* binding */ ParticleBase)\n/* harmony export */ });\nclass ParticleBase {\n  ctx = null;\n  behaviouralProperties = null;\n  constructor(props) {\n    // Override this method in the extended particle class\n  }\n  \n  isParticleAlive() {\n    // Override this method in the extended particle class\n    return false;\n  }\n  \n  setLifeTime(lifetime) {\n    // Override this method in the extended particle class\n  }\n  \n  getLifeTime() {\n    // Override this method in the extended particle class\n  }\n  \n  getWidth() {\n    // Override this method in the extended particle class\n  }\n  \n  getHeight() {\n    // Override this method in the extended particle class\n  }\n  \n  setPosition({x, y}){\n    // Override this method in the extended particle class\n  }\n  \n  getPosition() {\n    // Override this method in the extended particle class\n  }\n  \n  setRotation(rotation) {\n    // Override this method in the extended particle class\n  }\n  \n  setColor(color) {\n    // Override this method in the extended particle class\n  }\n  \n  draw() {\n    // Override this method in the extended particle class\n  }\n  \n}\n\n//# sourceURL=webpack://vanilla-js-particle-effects/./src/particle_factories/ParticleBase.js?");

/***/ }),

/***/ "./src/particle_factories/animated_geometry_particle_factory/AnimatedDiamondParticle.js":
/*!**********************************************************************************************!*\
  !*** ./src/particle_factories/animated_geometry_particle_factory/AnimatedDiamondParticle.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimatedDiamondParticle\": () => (/* binding */ AnimatedDiamondParticle)\n/* harmony export */ });\n/* harmony import */ var _ParticleBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParticleBase.js */ \"./src/particle_factories/ParticleBase.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils.js */ \"./src/utils.js\");\n\n\n\nclass AnimatedDiamondParticle extends _ParticleBase_js__WEBPACK_IMPORTED_MODULE_0__.ParticleBase {\n  constructor({ canvasContext, behaviouralProperties, initialX, initialY, size }) {\n    super();\n    this.ctx = canvasContext;\n    this.behaviouralProperties = behaviouralProperties;\n    this.x = initialX || 0;\n    this.y = initialY || 0;\n    this.size = size;\n    this.rotation = 0;\n    this.lifetime = 0;\n    this.randomContractionSpeed = Math.random() * (60 - 10) + 10;\n    this.color = '#fff';\n  }\n  \n  isParticleAlive() {\n    const isOutsideHorizontalViewport = (this.x < -this.getWidth() || this.x > this.ctx.canvas.width + this.getWidth());\n    const isOutsideVerticalViewport = (this.y < -this.getHeight() || this.y > this.ctx.canvas.height + this.getHeight());\n    \n    return !(isOutsideHorizontalViewport || isOutsideVerticalViewport);\n  }\n  \n  setLifeTime(lifetime) {\n    this.lifetime = lifetime;\n  }\n  \n  getLifeTime() {\n    return this.lifetime;\n  }\n  \n  getWidth() {\n    return this.size;\n  }\n  \n  getHeight() {\n    return this.size;\n  }\n  \n  setPosition({ x, y }) {\n    this.x = x;\n    this.y = y;\n  }\n  \n  getPosition() {\n    return { x: this.x, y: this.y };\n  }\n  \n  setRotation(rotation) {\n    this.rotation = rotation;\n  }\n  \n  setColor(color) {\n    this.color = color;\n  }\n  \n  /**\n   * Generate a rotated diamond-shaped polygon\n   * @param x\n   * @param y\n   * @param rotation\n   * @return {*[]}\n   * @private\n   */\n  _generatePolygon(x, y, rotation) {\n    // define center\n    const center = { x: x - this.getWidth() / 2, y: y - this.getHeight() / 2 };\n  \n    // Make the polygon 'wobble' by moving the left and right X positions inwards/outwards\n    const leftXPosRange = { min: center.x - (this.size / 2), max: center.x - (this.size / 4) };\n    const leftXPos = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.sineBetween)(leftXPosRange.max, leftXPosRange.min, (this.getLifeTime() / this.randomContractionSpeed));\n    const rightXPosRange = { min: center.x + (this.size / 4), max: center.x + (this.size / 2) };\n    const rightXPos = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.sineBetween)(rightXPosRange.min, rightXPosRange.max, (this.getLifeTime() / this.randomContractionSpeed));\n    \n    // Define polygon points\n    const polygonPoints = [\n      // top\n      { x: center.x, y: center.y - (this.size / 2) },\n      // right\n      { x: rightXPos, y: center.y },\n      // bottom\n      { x: center.x, y: center.y + (this.size / 2) },\n      // left\n      { x: leftXPos, y: center.y },\n      // top\n      { x: center.x, y: center.y - (this.size / 2) },\n    ];\n    \n    // Apply rotation\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotatePolygonAroundPoint)(polygonPoints, center, rotation);\n  }\n  \n  /**\n   * Draw a diamond at given x & y position, rotated given degrees\n   * @param x\n   * @param y\n   * @param rotation\n   * @private\n   */\n  _drawDiamondPolygon(x, y, rotation) {\n    const polygonPoints = this._generatePolygon(x, y, rotation);\n    this.ctx.beginPath();\n    this.ctx.moveTo(polygonPoints[0].x, polygonPoints[0].y);\n    for (let i = 0; i < polygonPoints.length; i++) {\n      this.ctx.lineTo(polygonPoints[i].x, polygonPoints[i].y);\n    }\n    this.ctx.strokeStyle = this.color;\n    this.ctx.stroke()\n    this.ctx.closePath();\n  }\n  \n  draw() {\n    // Draw layer 1\n    this._drawDiamondPolygon(this.x, this.y, this.rotation);\n    // Draw layer 2 - just behind layer 1\n    this._drawDiamondPolygon(this.x - ( this.size / 8), this.y - ( this.size / 8), this.rotation);\n  }\n}\n\n//# sourceURL=webpack://vanilla-js-particle-effects/./src/particle_factories/animated_geometry_particle_factory/AnimatedDiamondParticle.js?");

/***/ }),

/***/ "./src/particle_factories/animated_geometry_particle_factory/AnimatedGeometryParticleFactory.js":
/*!******************************************************************************************************!*\
  !*** ./src/particle_factories/animated_geometry_particle_factory/AnimatedGeometryParticleFactory.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimatedGeometryParticleFactory\": () => (/* binding */ AnimatedGeometryParticleFactory)\n/* harmony export */ });\n/* harmony import */ var _AnimatedDiamondParticle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimatedDiamondParticle.js */ \"./src/particle_factories/animated_geometry_particle_factory/AnimatedDiamondParticle.js\");\n\n\nclass AnimatedGeometryParticleFactory {\n  constructor({minWidth, maxWidth, shapes}) {\n    this.particleColors = shapes || ['diamond'];\n    this.sizeRange = {\n      min: minWidth || 10,\n      max: maxWidth || 20\n    };\n  }\n  \n  createParticle({canvasContext, initialX, initialY, behaviouralProperties}) {\n    let size = Math.random() * (this.sizeRange.max - this.sizeRange.min) + this.sizeRange.min;\n    \n    return new _AnimatedDiamondParticle_js__WEBPACK_IMPORTED_MODULE_0__.AnimatedDiamondParticle({\n      canvasContext: canvasContext,\n      behaviouralProperties: behaviouralProperties,\n      initialX: initialX,\n      initialY: initialY,\n      size,\n    })\n  }\n}\n\n//# sourceURL=webpack://vanilla-js-particle-effects/./src/particle_factories/animated_geometry_particle_factory/AnimatedGeometryParticleFactory.js?");

/***/ }),

/***/ "./src/particle_factories/image_particle_factory/ImageParticle.js":
/*!************************************************************************!*\
  !*** ./src/particle_factories/image_particle_factory/ImageParticle.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ImageParticle\": () => (/* binding */ ImageParticle)\n/* harmony export */ });\n/* harmony import */ var _ParticleBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParticleBase.js */ \"./src/particle_factories/ParticleBase.js\");\n\nclass ImageParticle extends _ParticleBase_js__WEBPACK_IMPORTED_MODULE_0__.ParticleBase {\n  constructor({ canvasContext, behaviouralProperties, initialX, initialY, image, scale, initialRotation }) {\n    super();\n    this.ctx = canvasContext;\n    this.behaviouralProperties = behaviouralProperties;\n    this.image = image;\n    this.imageWidth = this.image.width * scale;\n    this.imageHeight = this.image.height * scale;\n    this.x = initialX || 0;\n    this.y = initialY || 0;\n    this.rotation = initialRotation || 0;\n    this.lifetime = 0;\n  }\n  \n  isParticleAlive() {\n    const isOutsideHorizontalViewport = (this.x < -this.getWidth() || this.x > this.ctx.canvas.width + this.getWidth());\n    const isOutsideVerticalViewport = (this.y < -this.getHeight() || this.y > this.ctx.canvas.height + this.getHeight());\n    \n    return !(isOutsideHorizontalViewport || isOutsideVerticalViewport);\n  }\n  \n  setLifeTime(lifetime) {\n    this.lifetime = lifetime;\n  }\n  \n  getLifeTime() {\n    return this.lifetime;\n  }\n  \n  getWidth() {\n    return this.imageWidth;\n  }\n  \n  getHeight() {\n    return this.imageHeight;\n  }\n  \n  setPosition({x, y}){\n    this.x = x;\n    this.y = y;\n  }\n  \n  getPosition() {\n    return {x: this.x, y: this.y};\n  }\n  \n  setRotation(rotation) {\n    this.rotation = rotation;\n  }\n  \n  draw() {\n    if(this.image.imageLoaded){\n      this.ctx.translate(this.x, this.y);\n      this.ctx.rotate(this.rotation);\n      this.ctx.drawImage(this.image, -this.getWidth() / 2 , -this.getHeight() / 2, this.getWidth(), this.getHeight());\n      this.ctx.rotate(-this.rotation);\n      this.ctx.translate(-this.x, -this.y);\n    }\n  }\n}\n\n//# sourceURL=webpack://vanilla-js-particle-effects/./src/particle_factories/image_particle_factory/ImageParticle.js?");

/***/ }),

/***/ "./src/particle_factories/image_particle_factory/ImageParticleFactory.js":
/*!*******************************************************************************!*\
  !*** ./src/particle_factories/image_particle_factory/ImageParticleFactory.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ImageParticleFactory\": () => (/* binding */ ImageParticleFactory)\n/* harmony export */ });\n/* harmony import */ var _ImageParticle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageParticle.js */ \"./src/particle_factories/image_particle_factory/ImageParticle.js\");\n\n\nclass ImageParticleFactory {\n  images = [];\n  \n  constructor({ images, minScale, maxScale }) {\n    // We have some fallback images for our particles, which we can use if no images have been passed into the constructor\n    const fallbackImages = [\n      {\n        name: 'square',\n        src: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAMAAABHPGVmAAAAM1BMVEUAAAD9vQD9vQD9vQD9vQD9vQD9vQD9vQD9vQD9vQD9vQD9vQD9vQD9vQD9vQD9vQD9vQCEzyW/AAAAEHRSTlMAECAwQFBgcICPn6+/z9/vIxqCigAAAShJREFUeAHt2uFq7CAQxfGj5kYz68bz/k97l9KWTTcupHikH+b3An8mIUFwcEXMtfGh1RyhEY1PTJLJ/CFjOOMLkzcElcJTBQMldiSMU9lRBYMoR9nYtWGUnV07Bgl8I2CMhW8sEyMe8YhHPOIRj3jEI8uZPDCy2s7r8nIu4FUojWPtW8LRv0aBesgYRQq+hDtlDJ9upLxSKJXxECkWARjFDIiUi8iUy6iUq2iUa+AEHrlkzouvlKtzPsZIuTjnBykfpUU8ZEqt+GDqh6WuGL4VarQVT1KlgAUcpW3nULcccCIs535z4I64iO8s6POIRzziEY94xCMeaTMidUakzLhgTuzbMcp9xqX/yq4E/SgV4yzsSPOXY/RrPqKKYbjceJT/+hKZYB3uPxidICnZQ31BAAAAAElFTkSuQmCC\",\n      },\n      {\n        name: 'triangle',\n        src: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABcCAMAAACvFeCmAAAAM1BMVEUAAADtQS3tQS3tQS3tQS3tQS3tQS3tQS3tQS3tQS3tQS3tQS3tQS3tQS3tQS3tQS3tQS3qGOtVAAAAEHRSTlMAECAwQFBgcICPn6+/z9/vIxqCigAAAk5JREFUeAHd2N2y2yoMBeDFDxgDRnr/pz374kzb3dh4YbkznX73mZXIchDCEh//5/FHxNKG/mL0khxe5Leup4494B2568QoHlauiN6p0R5B6IaqbaKs6vBIOHSBbHig6KLmsMh1XSYRS8LQJzIWJNFnKmhZH6v2DD7FnmFPSUowpgRRG6LH3FC7gLmuLxgOM5u+omEi6EsSrh36EnH2Yhn62Im+JxhOEOlfRO91nPJ64yjx5xR26I2IM7tO1YBvQuXbmHwizeODbzrjF1tL0oPDbcenoZcOjwv+0Euy9LIfDpfcsfLa73wGm1L5ask0Y9Ywwlcr4kakP1oMh2ll+6vzxeIL1vGdXiimsZl8JA4EpxcCNQc1UBo1txTbBJ2pYtdJtQz1akxzHSAdeqozIQ2kxoRMa2po4r8mJIGUDCERpKjn/tFnchivmZV5zzrT5xPU55ueA4n6Wym29orUM838gLYy4WbqqwgowhVCL2TTeoG8yA0Qhp472AFyw62NHYmSXhCPG17oYZi/l/H7BfJsI/5b6sJdK/O3GfYSmKleJ35LXboEofLbWG7nWldv2JJxIotO+PUtVE/4TeoPtgVR58Ye8EPYh87Fpws16Xv5shOLj05su8wC0Y9WlbiXWYkjBkGrREznVs2+FraubN/psECc11aZmTiNKgjVnPF6imFGt2fYU+wZhoX6hiVJdJkkLPJdF3WPdUV0gRQ84rv9ZxDiUMqIsMiDiMiwik2nWsQb3Nb1Qt8cXuPS3j8C9uTwuhBLKb33VkqJAbz/ANmIMSZWkWGiAAAAAElFTkSuQmCC\",\n      },\n      {\n        name: 'line',\n        src: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAQCAMAAADXjyqxAAAASFBMVEUAAAABAAIBAQMCAQUBAAIBAQMDAgZ+SP98R/99R/97Rv59R/97Rv58R/9/SP97Rv57Rv57Rv57Rv58R/97Rv57Rv57Rv57Rv5jZm49AAAAF3RSTlMAAAAAAQECEyMkMVRhY2aHr7/F0tTk84juFNUAAABRSURBVHja7dTJFYAgFEPRqDjgjArpv1NpIjkuvA1k8/9DNewXRfIxdqja+FCoLD3QTIVaW0C4qTZjpdyJRD3wH/ncSKKe5YQtz2jJiiWQltS/EgmMXd6s1GYAAAAASUVORK5CYII=\",\n      },\n      {\n        name: 'pentagon',\n        src: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABjCAMAAABaOVXeAAAAM1BMVEUAAAA+gvc+gvc+gvc+gvc+gvc+gvc+gvc+gvc+gvc+gvc+gvc+gvc+gvc+gvc+gvc+gvezXsREAAAAEHRSTlMAECAwQFBgcICPn6+/z9/vIxqCigAAAjxJREFUeAG1muGunCAQRgcQVESG93/apjetyU3vBA87Pb83qxyZ79vICiDuVx9faDuS/A9KG9/oexBnch//oLt4Eq7xI3cUN1IfBprFiX0Mmxr8VNncyU+VjRZ/VVwZV8WVcVVcGVfFlXFVXBlXxZVxVVwZV8WVcVVcGVfFlXFVXJm/KqaMqwLKgCr9TNn2QlVP8f5E2THmXEFEzmVloY05u3yRF5Vt+kaV/GFN2f5O1cM7ZfKN+lrVQ1Z4lUpUEWVVHgpT9XCC5Seiiir7K+DGqh5iGxPuRxZWBSa4yG86V0UGrD8LAapwVBQRuVgEcWVNJNAw5cqiZFoLXFmRk6riyqo0qoora9KxKq5MuCquTLgqrkzswFmhEl1R1jBWcvO8sjGGztjCzdPWbe2IIBQ70C/JZnRyktUVwSgq4VgRlcyoF4zV490urSyYOH7kFLF8VbeXC5u9SPWypZMbIEyUmCoZk4fbjU0BMbZpmGxvhjFws0ElTKOje5RKnYRg9SgVndxpdvC1Tb9DWUiCcIwvfL5n/lzLx6WS5hPNQhKEY5pPq3pUyfRG8odVUvmHuK3Ml2tj68YPjlcJ2YIGfARwSIJwBLGAw/HiAcerZOdRzW1F7pWHI69PG1Tfw5lkTK0nHUzUMifIhmU20AmrKMjrZSppHs6k725XWwbF1ZZB0OFFwu+SOI3/suEknHWcA7c158YFxNFIa46jyeF8mZyDgDNNQgvyjnAMDv+jVKw6OHoEQYRC6/gq1iV+ATaATiIKa4OvAAAAAElFTkSuQmCC\",\n      },\n      {\n        name: 'circle',\n        src: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABsCAMAAACrb+cLAAAAM1BMVEUAAAAtqU8tqU8tqU8tqU8tqU8tqU8tqU8tqU8tqU8tqU8tqU8tqU8tqU8tqU8tqU8tqU8MEU6JAAAAEHRSTlMAECAwQFBgcICPn6+/z9/vIxqCigAAAY1JREFUeAHt2MGK8yAUQOGb2FjrX6vv/7Q/sxsY4RCOWQyTs9cPLqVyE3d3f6q9lMfVRupjjNe1xtbGV/lqgxVvsOINVrzBijdY8QYr3mDFG5Mey41JPa01hCKMxcq/MS5X6hiseIMVb3jFG6x4gxVvaAUMoYDRn/teulAmxvyuNFP2tcZcadtaQytgLFQKGCuUzAYr3mDFG6x4gxVvsOINVryhFTSEIgxWhAFK1YZQ2PDKwYZWUmfDKmx4JXW946TJBS9+CGuc6jW5Yo9vfWbIcQ550Czago3woCvK8Mvte/LL4Y2tnTIyDnyuVGnkCK+w8UPprFgjIpEiDFDKKYPPzZXMBk9AK2AIRRikCIMfyGwMPgYKGqjwG5n5H88qc2MLr3iDFW+wIoxJlRRhgLKx4ZW28TiXKGx4ZY+IAoZWxrt+2PCfndcasTVvLFPY8EqOsIowhAKGUMDwSmfDl7owvFKC8kqNWK+w4RU2vMKG72BjQZmNtUoLyitti8sVNrzyBkO3P8sRv7W7u7v/sSm7FcXgsvQAAAAASUVORK5CYII=\"\n      }\n    ];\n    \n    const medias = images || fallbackImages;\n    this.images = medias.map((media) => {\n      const image = new Image;\n      image.src = media.src;\n      image.onload = () => {\n        image.imageLoaded = true;\n      };\n      return image;\n    });\n  \n    this.scaleRange = {\n      min: minScale || 0.1,\n      max: maxScale || 0.5\n    };\n  }\n  \n  createParticle({canvasContext, initialX, initialY, behaviouralProperties}) {\n    const particleImage = this.images[Math.floor(Math.random() * this.images.length)];\n    const scale = Math.random() * (this.scaleRange.max - this.scaleRange.min) + this.scaleRange.min;\n    return new _ImageParticle_js__WEBPACK_IMPORTED_MODULE_0__.ImageParticle({\n      canvasContext: canvasContext,\n      behaviouralProperties: behaviouralProperties,\n      initialX: initialX,\n      initialY: initialY,\n      image: particleImage,\n      scale: scale\n    })\n  }\n}\n\n//# sourceURL=webpack://vanilla-js-particle-effects/./src/particle_factories/image_particle_factory/ImageParticleFactory.js?");

/***/ }),

/***/ "./src/particle_factories/micro_organism_particle_factory/MicroOrganismParticle.js":
/*!*****************************************************************************************!*\
  !*** ./src/particle_factories/micro_organism_particle_factory/MicroOrganismParticle.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MicroOrganismParticle\": () => (/* binding */ MicroOrganismParticle)\n/* harmony export */ });\n/* harmony import */ var _ParticleBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ParticleBase.js */ \"./src/particle_factories/ParticleBase.js\");\n\nclass MicroOrganismParticle extends _ParticleBase_js__WEBPACK_IMPORTED_MODULE_0__.ParticleBase {\n  constructor({ canvasContext, behaviouralProperties, initialX, initialY, radius, color}) {\n    super();\n    this.ctx = canvasContext;\n    this.behaviouralProperties = behaviouralProperties;\n    this.x = initialX || 0;\n    this.y = initialY || 0;\n    this.radius = radius;\n    this.color = color;\n    this.lifetime = 0;\n  }\n  \n  isParticleAlive() {\n    const isOutsideHorizontalViewport = (this.x < -this.getWidth() || this.x > this.ctx.canvas.width + this.getWidth());\n    const isOutsideVerticalViewport = (this.y < -this.getHeight() || this.y > this.ctx.canvas.height + this.getHeight());\n    \n    return !(isOutsideHorizontalViewport || isOutsideVerticalViewport);\n  }\n  \n  setLifeTime(lifetime) {\n    this.lifetime = lifetime;\n  }\n  \n  getLifeTime() {\n    return this.lifetime;\n  }\n  \n  getWidth() {\n    return this.radius * 2;\n  }\n  \n  getHeight() {\n    return this.radius * 2;\n  }\n  \n  setPosition({x, y}){\n    this.x = x;\n    this.y = y;\n  }\n  \n  getPosition() {\n    return {x: this.x, y: this.y};\n  }\n  \n  setColor(color) {\n    this.color = color;\n  }\n  \n  draw() {\n    this.ctx.beginPath();\n    this.ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);\n    this.ctx.lineWidth = 2;\n    this.ctx.fillStyle = this.color;\n    this.ctx.fill();\n    this.ctx.closePath();\n  }\n}\n\n//# sourceURL=webpack://vanilla-js-particle-effects/./src/particle_factories/micro_organism_particle_factory/MicroOrganismParticle.js?");

/***/ }),

/***/ "./src/particle_factories/micro_organism_particle_factory/MicroOrganismParticleFactory.js":
/*!************************************************************************************************!*\
  !*** ./src/particle_factories/micro_organism_particle_factory/MicroOrganismParticleFactory.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MicroOrganismParticleFactory\": () => (/* binding */ MicroOrganismParticleFactory)\n/* harmony export */ });\n/* harmony import */ var _MicroOrganismParticle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MicroOrganismParticle.js */ \"./src/particle_factories/micro_organism_particle_factory/MicroOrganismParticle.js\");\n\n\nclass MicroOrganismParticleFactory {\n  constructor({minRadius, maxRadius, particleColors}) {\n    this.particleColors = particleColors || ['#F9314C', '#d8002c', '#7DFFF2'];\n    this.sizeRange = {\n      min: minRadius || Math.random(),\n      max: maxRadius || Math.random() * 3\n    };\n  }\n  \n  createParticle({canvasContext, initialX, initialY, behaviouralProperties}) {\n    let radius = Math.random() * (this.sizeRange.max - this.sizeRange.min) + this.sizeRange.min;\n    let color = this.particleColors[Math.floor(Math.random() * this.particleColors.length)];\n    \n    return new _MicroOrganismParticle_js__WEBPACK_IMPORTED_MODULE_0__.MicroOrganismParticle({\n      canvasContext: canvasContext,\n      behaviouralProperties: behaviouralProperties,\n      initialX: initialX,\n      initialY: initialY,\n      radius,\n      color\n    })\n  }\n}\n\n//# sourceURL=webpack://vanilla-js-particle-effects/./src/particle_factories/micro_organism_particle_factory/MicroOrganismParticleFactory.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"debounce\": () => (/* binding */ debounce),\n/* harmony export */   \"rotatePolygonAroundPoint\": () => (/* binding */ rotatePolygonAroundPoint),\n/* harmony export */   \"sineBetween\": () => (/* binding */ sineBetween),\n/* harmony export */   \"calculateDistance\": () => (/* binding */ calculateDistance)\n/* harmony export */ });\nconst debounce = (func, wait, immediate) => {\n  let timeout;\n  return function() {\n    const context = this,\n      args = arguments;\n    const later = function () {\n      timeout = null;\n      if (!immediate) func.apply(context, args);\n    };\n    const callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) func.apply(context, args);\n  };\n};\n\n/**\n * Rotate a given list of polygon coordinates around a given point (x,y)\n * @param coordsArray - List of coordinates that represent a polygon\n * @param point - Coordinate around which we want the polygon to rotate\n * @param rotation - Rotation in degrees\n * @return {Uint8Array | BigInt64Array | {x: *, y: *}[] | Float64Array | Int8Array | Float32Array | Int32Array | Uint32Array | Uint8ClampedArray | BigUint64Array | Int16Array | Uint16Array}\n */\nconst rotatePolygonAroundPoint = (coordsArray, point, rotation) => {\n  const s = Math.sin(rotation);\n  const c = Math.cos(rotation);\n  return coordsArray.map((coordinate) => {\n    const relativeX = coordinate.x - point.x;\n    const relativeY = coordinate.y - point.y;\n    const rotatedX = relativeX * c - relativeY * s;\n    const rotatedY = relativeX * s + relativeY * c;\n    return {x: point.x + rotatedX, y: point.y + rotatedY}\n  })\n};\n\n/**\n * Return a value that sines between a min and a max value, based on given arbitrary time value\n * @param min\n * @param max\n * @param t\n * @return {*}\n */\nconst sineBetween = (min, max, t) => {\n  const halfRange = (max - min) / 2;\n  return min + halfRange + Math.sin(t) * halfRange;\n};\n\n/**\n * Calculate distance between 2 coordinates\n * @param point1\n * @param point2\n * @return {number}\n */\nconst calculateDistance = (point1, point2) => {\n  let x = Math.abs(point1.x - point2.x);\n  let y = Math.abs(point1.y - point2.y);\n  return Math.sqrt((x * x) + (y * y));\n};\n\n//# sourceURL=webpack://vanilla-js-particle-effects/./src/utils.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;